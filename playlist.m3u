# convert.py (ULTRA-AGGRESSIVE FILTER: Checks for 2xx AND content type)

import json
import os
import sys
import requests

OUTPUT_FILE_NAME = "playlist.m3u"
EPG_URL = "https://avkb.short.gy/jioepg.xml.gz"

# --- Function to check stream validity aggressively ---
def is_stream_live_or_valid(url):
    """
    Aggressively checks for stream validity by ensuring the response is 2xx 
    AND the content type is related to video/MPEG-DASH, or is otherwise small.
    """
    if not url:
        return False
    
    try:
        # Use a GET request with a very short timeout and stream=True
        # We only want the initial headers and a tiny bit of content, if any.
        with requests.get(url, timeout=3, allow_redirects=True, stream=True) as response:
            
            # If status is NOT a success code (e.g., 403, 404, 5xx), the link is bad.
            if not 200 <= response.status_code < 300:
                print(f"   [CHECK] Failed with status code: {response.status_code}")
                return False
            
            # CHECK 1: Ensure it's not redirecting to an off-air placeholder
            # Check the actual content type header expected for an MPD/M3U8 file
            content_type = response.headers.get('Content-Type', '').lower()
            if 'html' in content_type or 'text' in content_type:
                 print(f"   [CHECK] Failed: Content type is HTML/Text (Placeholder).")
                 return False

            # CHECK 2: Check for minimum content length (if available)
            content_length = int(response.headers.get('Content-Length', 0))
            if content_length < 1000 and content_length != 0: 
                 # Very small content often means an empty or minimal placeholder file
                 print(f"   [CHECK] Failed: Content too small ({content_length} bytes).")
                 return False

            # If it returns 2xx AND doesn't look like a placeholder page, we keep it.
            return True
            
    except requests.exceptions.RequestException as e:
        # Catches all connection failures (timeouts, DNS, severe geo-blocks)
        return False
# --------------------------------------------------------------------------


def json_to_m3u(json_url):
    print(f"Fetching data from URL...")
    # ... (JSON fetching and data initialization remains the same)
    try:
        response = requests.get(json_url, timeout=15)
        response.raise_for_status()
        data = response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching or decoding JSON: {e}")
        sys.exit(1)
        
    if not isinstance(data, list):
        print("Error: JSON root must be a list of stream objects. Check your JSON format.")
        sys.exit(1)

    m3u_lines = [
        "#EXTM3U",
        f'#EXTM3U x-tvg-url="{EPG_URL}"'
    ]
    
    working_channel_count = 0
    
    for stream in data:
        channel_name = stream.get('channel_name', 'Unknown Channel')
        stream_url = stream.get('channel_url', '')

        # === AGGRESSIVE VALIDATION ===
        print(f"⚙️ Validating: {channel_name}...")
        if not is_stream_live_or_valid(stream_url):
            print(f"❌ Removing: {channel_name} (Failed aggressive content check).")
            continue
        
        working_channel_count += 1
        
        # --- A. BUILD #EXTINF LINE (remains the same) ---
        extinf_parts = ["#EXTINF:-1"]
        
        # M3U Attributes based on your JSON keys
        if stream.get('channel_id'):
            extinf_parts.append(f'tvg-id="{stream["channel_id"]}"')
        if stream.get('channel_genre'):
            extinf_parts.append(f'group-title="{stream["channel_genre"]}"')
        if stream.get('channel_logo'):
            extinf_parts.append(f'tvg-logo="{stream["channel_logo"]}"')
        
        extinf_line = " ".join(extinf_parts) + f",{channel_name}"
        m3u_lines.append(extinf_line)

        # --- B. COMBINE URL AND COOKIE (Player compatibility fix) ---
        final_stream_line = stream_url
        cookie_value = stream.get('cookie')
        
        if cookie_value:
            # Append cookie and user-agent using the universal '|' separator
            final_stream_line = f'{stream_url}|User-Agent=plaYtv/7.1.3 (Linux;Android 13) ygx/69.1 ExoPlayerLib/824.0&Cookie={cookie_value}'
            
        m3u_lines.append(final_stream_line)
        
    # 5. Write the M3U file
    try:
        with open(OUTPUT_FILE_NAME, 'w', encoding='utf-8') as f:
            f.write('\n'.join(m3u_lines) + '\n')
        print(f"\n✅ Conversion complete. Wrote {working_channel_count} filtered streams to {OUTPUT_FILE_NAME}")
    except IOError as e:
        print(f"Error writing to output file {OUTPUT_FILE_NAME}: {e}")
        sys.exit(1)

if __name__ == "__main__":
    url = os.getenv('JSON_SOURCE_URL')
    if not url:
        print("Fatal Error: JSON_SOURCE_URL environment variable is not set.")
        sys.exit(1)
        
    json_to_m3u(url)
